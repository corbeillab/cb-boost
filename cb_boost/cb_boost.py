import logging
import math
import time

import numpy as np
import numpy.ma as ma
import scipy
from sklearn.base import BaseEstimator, ClassifierMixin
from sklearn.utils.validation import check_is_fitted
from sklearn.metrics import zero_one_loss

from .utils import sign, change_label_to_minus
from .classifier_generators import StumpsClassifiersGenerator, \
    TreeClassifiersGenerator

class BaseBoost(object):

    def _collect_probas(self, X, sub_sampled=False):
        if self.estimators_generator.__class__.__name__ == "TreeClassifiersGenerator":
            return np.asarray([clf.predict_proba(X[:, attribute_indices]) for
                               clf, attribute_indices in
                               zip(self.estimators_generator.estimators_,
                                   self.estimators_generator.attribute_indices)])
        else:
            return np.asarray([clf.predict_proba(X) for clf in
                               self.estimators_generator.estimators_])

    def _binary_classification_matrix(self, X):
        probas = self._collect_probas(X)
        predicted_labels = np.argmax(probas, axis=2)
        predicted_labels[predicted_labels == 0] = -1
        values = np.max(probas, axis=2)
        return (predicted_labels * values).T

    def _initialize_alphas(self, n_examples):
        raise NotImplementedError(
            "Alpha weights initialization function is not implemented.")

    def check_opposed_voters(self, ):
        nb_opposed = 0
        oppposed = []
        for column in self.classification_matrix[:,
                      self.chosen_columns_].transpose():
            for chosen_col in self.chosen_columns_:
                if (-column.reshape((self.n_total_examples,
                                     1)) == self.classification_matrix[:,
                                            chosen_col].reshape(
                        (self.n_total_examples, 1))).all():
                    nb_opposed += 1
                    break
        return int(nb_opposed / 2)


class CBBoostClassifier(BaseEstimator, ClassifierMixin, BaseBoost):
    def __init__(self, n_max_iterations=100, estimators_generator="Stumps",
                 random_state=42, self_complemented=True, twice_the_same=True,
                 random_start=False, n_stumps=1, c_bound_sol=True,
                 plotted_metric=zero_one_loss, save_train_data=True,
                 test_graph=True, mincq_tracking=False, max_depth=1):
        super(CBBoostClassifier, self).__init__()
        r"""One of the main limitations of CB-Boost is that it has to 
        pre-generate the potential voters, as there is not efficient way to 
        build a stump that optimizes the C-Bound criterion. This lead has been 
        inverstigated and may lead to a new kind of stump code. But it is not a 
        very popular research field, so it has not been pursued yet. 

            Parameters
            ----------
            n_max_iterations : int
                Maximum number of iterations for the boosting algorithm.
            estimators_generator : object
                Sk-learn classifier object used to generate the hypotheses with the data.
            random_state : np.random.RandomState or int
                The random state, used in order to be reproductible
            self_complemented : bool
                If True, in the hypotheses generation process, for each hypothesis, it's complement will be generated too.
            twice_the_same : bool
                If True, the algorithm will be allowed to select twice the same hypothesis in the boosting process.
            c_bound_choice : bool
                If True, the C-Bound will be used to select the hypotheses. If False, the margin will be the criterion.
            n_stumps_per_attribute : int
                The number of hypotheses generated by data attribute 
            use_r : bool
                If True, uses edge to compute the performance of a voter. If False, use the error instead.
            plotted_metric : Metric module
                The metric that will be plotted for each iteration of boosting. 
            """
        if type(random_state) is int:
            self.random_state = np.random.RandomState(random_state)
        else:
            self.random_state = random_state
        self.train_time = 0
        self.max_depth=max_depth
        self.train_shape = None
        self.step_decisions = None
        self.step_prod = None
        self.n_max_iterations = n_max_iterations
        self.estimators_generator = estimators_generator
        self.estimators_generator_name = estimators_generator
        self.self_complemented = self_complemented
        self.twice_the_same = twice_the_same
        self.random_start = random_start
        self.plotted_metric = plotted_metric
        self.n_stumps = n_stumps
        self.c_bound_sol = c_bound_sol
        self.save_train_data = save_train_data
        self.test_graph = test_graph
        self.printed_args_name_list = ["n_max_iterations", "self_complemented",
                                       "twice_the_same",
                                       "random_start",
                                       "n_stumps",]
        self.mincq_tracking = mincq_tracking

    def fit(self, X, y):
        self.n_features = X.shape[1]
        formatted_X, formatted_y = self.format_X_y(X, y)

        self.init_info_containers()

        # Initialize the weak classifiers ensemble
        m, n, y_kernel_matrix = self.init_hypotheses(formatted_X, formatted_y)

        start = time.time()
        self.n_total_hypotheses_ = n
        self.n_total_examples = m

        # Initialize the majority vote
        self.init_boosting(m, formatted_y, y_kernel_matrix)

        self.break_cause = " the maximum number of iterations was attained."

        for k in range(min(n - 1,
                           self.n_max_iterations - 1 if self.n_max_iterations is not None else np.inf)):

            self.it = k

            # Find the best (weight, voter) couple.
            self.q, new_voter_index = self._find_new_voter(y_kernel_matrix,
                                                        formatted_y, formatted_X)

            if type(self.q) == str:
                self.break_cause = new_voter_index  #
                break

            self.append_new_voter(new_voter_index)
            self.weights_.append(self.q)

            voter_perf = self.compute_voter_perf(formatted_y)

            self.update_info_containers(formatted_y, voter_perf, k)

        self.estimators_generator.choose(self.chosen_columns_)
        self.nb_opposed_voters = self.check_opposed_voters()
        if self.save_train_data:
            self.X_train = self.classification_matrix[:, self.chosen_columns_]
            self.raw_weights = self.weights_
            self.y_train = formatted_y

        self.weights_ = np.array(self.weights_)/np.sum(np.array(self.weights_))

        formatted_y[formatted_y == -1] = 0
        formatted_y = formatted_y.reshape((m,))

        end = time.time()
        self.train_time = end - start
        self.feature_importances_ = np.zeros(X.shape[1])
        for iter_index, iteration_feature_imporances in enumerate(self.chosen_features):
            for feature_index, importance in iteration_feature_imporances:
                self.feature_importances_[feature_index] += importance*self.weights_[iter_index]
        self.feature_importances_ /= np.sum(self.feature_importances_)
        return self

    def predict_proba(self, X):
        start = time.time()
        check_is_fitted(self, 'weights_')
        if scipy.sparse.issparse(X):
            logging.warning('Converting sparse matrix to dense matrix.')
            X = np.array(X.todense())

        classification_matrix = self._binary_classification_matrix(X)
        margins = np.sum(classification_matrix * self.weights_, axis=1)
        proba = np.array([np.array([(1 - vote)/2, (1 + vote)/2]) for vote in margins])
        return proba

    def predict(self, X):
        start = time.time()
        check_is_fitted(self, 'weights_')
        if scipy.sparse.issparse(X):
            logging.warning('Converting sparse matrix to dense matrix.')
            X = np.array(X.todense())

        classification_matrix = self._binary_classification_matrix(X)
        margins = np.sum(classification_matrix * self.weights_, axis=1)
        signs_array = np.array([int(x) for x in sign(margins)])
        signs_array[signs_array == -1] = 0

        end = time.time()
        self.predict_time = end - start

        # Predict for each step of the boosting process
        self.step_predict(classification_matrix)

        return signs_array

    def step_predict(self, classification_matrix):
        """Used to predict with each step of the greedy algorithm to analyze its performance increase"""
        if classification_matrix.shape != self.train_shape:
            self.step_decisions = np.zeros(classification_matrix.shape)
            self.mincq_step_decisions = np.zeros(classification_matrix.shape)
            self.step_prod = np.zeros(classification_matrix.shape)
            for weight_index in range(self.weights_.shape[0] - 1):
                margins = np.sum(
                    classification_matrix[:, :weight_index + 1] * self.weights_[
                                                                  :weight_index + 1],
                    axis=1)
                signs_array = np.array([int(x) for x in sign(margins)])
                signs_array[signs_array == -1] = 0
                self.step_decisions[:, weight_index] = signs_array
                self.step_prod[:, weight_index] = np.sum(
                    classification_matrix[:, :weight_index + 1] * self.weights_[
                                                                  :weight_index + 1],
                    axis=1)
                if self.mincq_tracking:
                    if weight_index == 0:
                        self.mincq_step_decisions[:, weight_index] = signs_array
                    else:
                        mincq_margins = np.sum(self.mincq_learners[
                                                   weight_index - 1].majority_vote._weights * classification_matrix[
                                                                                              :,
                                                                                              :weight_index + 1],
                                               axis=1)
                        mincq_signs_array = np.array(
                            [int(x) for x in sign(mincq_margins)])
                        mincq_signs_array[mincq_signs_array == -1] = 0
                        self.mincq_step_decisions[:,
                        weight_index] = mincq_signs_array

    def update_info_containers(self, y, voter_perf, k):
        """Is used at each iteration to compute and store all the needed quantities for later analysis"""
        self.tau.append(
            np.sum(np.multiply(self.previous_vote, self.new_voter)) / float(
                self.n_total_examples))
        # print(np.sum(np.multiply(self.previous_vote, self.new_voter))/float(self.n_total_examples))
        self.previous_vote += self.q * self.new_voter
        self.norm.append(np.linalg.norm(self.previous_vote) ** 2)
        self.previous_votes.append(self.previous_vote)
        self.previous_margins.append(
            np.sum(np.multiply(y, self.previous_vote)) / float(
                self.n_total_examples))
        self.selected_margins.append(
            np.sum(np.multiply(y, self.new_voter)) / float(
                self.n_total_examples))

        # Used to compute the optimal c-bound distribution on the chose set

    def compute_voter_perf(self, formatted_y):
        """Used to computer the performance (error or edge) of the selected voter"""
        epsilon = self._compute_epsilon(formatted_y)
        self.voter_perfs.append(epsilon)
        return epsilon

    def _compute_epsilon(self, y):
        """Updating the error variable, the old fashioned way uses the whole majority vote to update the error"""
        ones_matrix = np.zeros(y.shape)
        ones_matrix[np.multiply(y, self.new_voter.reshape(
            y.shape)) < 0] = 1  # can np.divide if needed
        epsilon = np.average(np.multiply(y, self.new_voter.reshape(
            y.shape)), axis=0)
        return epsilon

    def append_new_voter(self, new_voter_index):
        """Used to append the voter to the majority vote"""
        self.chosen_columns_.append(new_voter_index)
        if self.estimators_generator_name=="Stumps":
            self.chosen_features.append([(int(new_voter_index%(self.n_stumps*self.n_features)/self.n_stumps), 1)])
        elif self.estimators_generator_name == "Trees":
            self.chosen_features.append([(self.estimators_generator.attribute_indices[new_voter_index][fake_ind], importance)
                                         for fake_ind, importance
                                         in enumerate(self.estimators_generator.estimators_[new_voter_index].feature_importances_)
                                         if importance>0])
        self.new_voter = self.classification_matrix[:, new_voter_index].reshape(
            (self.n_total_examples, 1))

    def init_boosting(self, m, y, y_kernel_matrix):
        """THis initialization corressponds to the first round of boosting with equal weights for each examples and the voter chosen by it's margin."""

        if self.random_start:
            first_voter_index = self.random_state.choice(
                np.where(np.sum(y_kernel_matrix, axis=0) > 0)[0])
        else:
            first_voter_index, _ = self._find_best_weighted_margin(
                y_kernel_matrix)

        self.chosen_columns_.append(first_voter_index)
        self.ths.append((self.estimators_generator.estimators_[first_voter_index].threshold, self.estimators_generator.estimators_[first_voter_index].attribute_index))
        self.new_voter = np.array(self.classification_matrix[:,
                                  first_voter_index].reshape((m, 1)), copy=True)

        self.previous_vote = self.new_voter
        self.norm.append(np.linalg.norm(self.previous_vote) ** 2)
        self.try_ = []
        self.try_2=[]
        self.q = 1
        self.weights_.append(self.q)

        self.previous_margins.append(
            np.sum(np.multiply(y, self.previous_vote)) / float(
                self.n_total_examples))
        self.selected_margins.append(np.sum(np.multiply(y, self.previous_vote)))
        self.tau.append(
            np.sum(np.multiply(self.previous_vote, self.new_voter)) / float(
                self.n_total_examples))

    def format_X_y(self, X, y):
        """Formats the data  : X -the examples- and y -the labels- to be used properly by the algorithm """
        if scipy.sparse.issparse(X):
            logging.info('Converting to dense matrix.')
            X = np.array(X.todense())
        # Initialization
        y_neg = change_label_to_minus(y)
        y_neg = y_neg.reshape((y.shape[0], 1))
        return X, y_neg

    def init_hypotheses(self, X, y):
        """Inintialization for the hyptotheses used to build the boosted vote"""
        if self.estimators_generator is "Stumps":
            self.estimators_generator = StumpsClassifiersGenerator(
                n_stumps_per_attribute=self.n_stumps,
                self_complemented=self.self_complemented)
        if self.estimators_generator is "Trees":
            self.estimators_generator = TreeClassifiersGenerator(
                n_trees=self.n_stumps, max_depth=self.max_depth,
                self_complemented=self.self_complemented)
        self.estimators_generator.fit(X, y)
        self.classification_matrix = self._binary_classification_matrix(X)
        self.train_shape = self.classification_matrix.shape

        m, n = self.classification_matrix.shape
        y_kernel_matrix = np.multiply(y, self.classification_matrix)

        return m, n, y_kernel_matrix

    def init_info_containers(self):
        """Initialize the containers that will be collected at each iteration for the analysis"""
        self.weights_ = []
        self.chosen_features = []
        self.chosen_columns_ = []
        self.fobidden_columns = []
        self.c_bounds = []
        self.voter_perfs = []
        self.example_weights_ = []
        self.train_metrics = []
        self.bounds = []
        self.ths = []
        self.disagreements = []
        self.margins = []
        self.previous_votes = []
        self.previous_margins = []
        self.respected_bound = True
        self.selected_margins = []
        self.tau = []
        self.norm = []
        self.mincq_train_metrics = []
        self.mincq_c_bounds = []
        self.mincq_weights = []
        self.mincq_learners = []
        self.mincq_step_decisions = []


    def _find_best_weighted_margin(self, y_kernel_matrix, upper_bound=1.0,
                                   lower_bound=0.0):
        """Finds the new voter by choosing the one that has the best weighted margin between 0.5 and 0.55
        to avoid too god voters that will get all the votes weights"""
        pseudo_h_values = ma.array(np.sum(y_kernel_matrix, axis=0),
                                   fill_value=-np.inf)
        pseudo_h_values[self.chosen_columns_] = ma.masked
        return np.argmax(pseudo_h_values), [0]

    def _find_new_voter(self, y_kernel_matrix, y, formatted_X):
        """Here, we solve the two_voters_mincq_problem for each potential new voter,
        and select the one that has the smallest minimum"""
        m = y_kernel_matrix.shape[0]
        previous_sum = np.multiply(y,
                                            self.previous_vote.reshape(m, 1))
        margin_old = np.sum(previous_sum)
        worst_example = 0
        # worst_example = np.argmin(previous_sum)


        bad_margins = np.where(np.sum(y_kernel_matrix, axis=0) <= 0.0)[0]

        self.B2 = m
        self.B1s = np.sum(
            2 * np.multiply(previous_sum, y_kernel_matrix),
            axis=0)
        self.B0 = np.sum(previous_sum ** 2)

        self.A2s = np.sum(y_kernel_matrix, axis=0) ** 2
        self.A1s = np.sum(y_kernel_matrix, axis=0) * margin_old * 2
        self.A0 = margin_old ** 2

        C2s = (self.A1s * self.B2 - self.A2s * self.B1s)
        C1s = 2 * (self.A0 * self.B2 - self.A2s * self.B0)
        C0s = self.A0 * self.B1s - self.A1s * self.B0

        sols = np.zeros(C0s.shape) - 3
        sols[np.where(C2s != 0)[0]] = (-C1s[np.where(C2s != 0)[0]] + np.sqrt(
            C1s[np.where(C2s != 0)[0]] * C1s[np.where(C2s != 0)[0]] - 4 * C2s[
                np.where(C2s != 0)[0]] * C0s[np.where(C2s != 0)[0]])) / (
                                                  2 * C2s[
                                              np.where(C2s != 0)[0]])

        masked_c_bounds = self.make_masked_c_bounds(sols, bad_margins)
        if masked_c_bounds.mask.all():
            return "No more pertinent voters", 0
        else:
            best_hyp_index = np.argmin(masked_c_bounds)
            # self.try_.append(np.ravel(previous_sum) )
            #
            # self.try_2.append(np.reshape(previous_sum ** 2, (87,)) + (2 * sols[best_hyp_index]*y_kernel_matrix[:, best_hyp_index]*np.reshape(previous_sum, (87, ))))
            self.c_bounds.append(masked_c_bounds[best_hyp_index])
            self.margins.append(math.sqrt(self.A2s[best_hyp_index] / m))
            self.disagreements.append(0.5 * self.B1s[best_hyp_index] / m)
            self.ths.append((self.estimators_generator.estimators_[best_hyp_index].threshold, self.estimators_generator.estimators_[best_hyp_index].attribute_index))
            return sols[best_hyp_index], best_hyp_index

    def make_masked_c_bounds(self, sols, bad_margins):
        c_bounds = self.compute_c_bounds(sols)
        trans_c_bounds = self.compute_c_bounds(sols + 1)
        masked_c_bounds = ma.array(c_bounds, fill_value=np.inf)
        # Masing Maximums
        masked_c_bounds[c_bounds >= trans_c_bounds] = ma.masked
        # Masking magrins <= 0
        masked_c_bounds[bad_margins] = ma.masked
        # Masking weights < 0 (because self-complemented)
        masked_c_bounds[sols < 0] = ma.masked
        # Masking nan c_bounds
        masked_c_bounds[np.isnan(c_bounds)] = ma.masked
        if not self.twice_the_same:
            masked_c_bounds[self.chosen_columns_] = ma.masked
        return masked_c_bounds

    def compute_c_bounds(self, sols):
        return 1 - (self.A2s * sols ** 2 + self.A1s * sols + self.A0) / ((
                                                                                 self.B2 * sols ** 2 + self.B1s * sols + self.B0) * self.n_total_examples)

    def _cbound(self, sol):
        """Computing the objective function"""
        return 1 - (self.A2 * sol ** 2 + self.A1 * sol + self.A0) / ((
                                                                             self.B2 * sol ** 2 + self.B1 * sol + self.B0) * self.n_total_examples)

    def disagreement(self, sol):
        return (
                           self.B2 * sol ** 2 + self.B1 * sol + self.B0) / self.n_total_examples

    def margin(self, sol):
        return (
                           self.A2 * sol ** 2 + self.A1 * sol + self.A0) / self.n_total_examples

    def _best_sol(self, sols):
        """Return the best min in the two possible sols"""
        values = np.array([self._cbound(sol) for sol in sols])
        return sols[np.argmin(values)]
